# -*- coding: utf-8 -*-
"""Project_phase2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k7-RO5FBVk3R98UsDBSljkI74GipF6hj

Upload the Dataset
"""

from google.colab import files
uploaded = files.upload()

""" Load the Dataset

"""

import pandas as pd

# Sample data (manually defined)
data = [
    {"text": "I'm feeling great today!", "emotion": "joy"},
    {"text": "This is so frustrating and annoying.", "emotion": "anger"},
    {"text": "I miss you so much.", "emotion": "sadness"},
    {"text": "Iâ€™m scared about the future.", "emotion": "fear"},
    {"text": "What a wonderful surprise!", "emotion": "surprise"}
]

# Create DataFrame
df = pd.DataFrame(data)

# Display the data
print(df)

"""Data Exploration"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Sample social media emotion dataset
data = [
    {"text": "I'm feeling great today!", "emotion": "joy"},
    {"text": "This is so frustrating and annoying.", "emotion": "anger"},
    {"text": "I miss you so much.", "emotion": "sadness"},
    {"text": "Iâ€™m scared about the future.", "emotion": "fear"},
    {"text": "What a wonderful surprise!", "emotion": "surprise"},
    {"text": "Iâ€™m so proud of myself!", "emotion": "joy"},
    {"text": "Everything is going wrong!", "emotion": "anger"},
    {"text": "I just want to cry.", "emotion": "sadness"},
    {"text": "That really shocked me!", "emotion": "surprise"},
    {"text": "I feel anxious and nervous.", "emotion": "fear"}
]

# Create DataFrame
df = pd.DataFrame(data)

# Display first few rows
print("Dataset Preview:\n", df.head())

# Dataset shape
print("\nDataset Shape:", df.shape)

# Data types
print("\nData Types:\n", df.dtypes)

# Check for missing values
print("\nMissing Values:\n", df.isnull().sum())

# Emotion class distribution
print("\nEmotion Distribution:\n", df['emotion'].value_counts())

# Plotting emotion distribution
plt.figure(figsize=(8, 5))
sns.countplot(data=df, x='emotion', palette='Set2')
plt.title('Emotion Distribution in Social Media Posts')
plt.xlabel('Emotion')
plt.ylabel('Count')
plt.grid(True)
plt.tight_layout()
plt.show()

"""Check for Missing Values and Duplicates"""

import pandas as pd

# Sample data (no CSV)
data = [
    {"text": "I'm feeling great today!", "emotion": "joy"},
    {"text": "This is so frustrating and annoying.", "emotion": "anger"},
    {"text": "I miss you so much.", "emotion": "sadness"},
    {"text": "Iâ€™m scared about the future.", "emotion": "fear"},
    {"text": "What a wonderful surprise!", "emotion": "surprise"},
    {"text": "Iâ€™m so proud of myself!", "emotion": "joy"},
    {"text": "Everything is going wrong!", "emotion": "anger"},
    {"text": "I just want to cry.", "emotion": "sadness"},
    {"text": "That really shocked me!", "emotion": "surprise"},
    {"text": "I feel anxious and nervous.", "emotion": "fear"}
]
df = pd.DataFrame(data)
print("Missing Values:\n", df.isnull().sum())
print("\nDuplicate rows:", df.duplicated().sum())

"""Visualize a Few Features"""

import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import CountVectorizer
import numpy as np

# Fit the vectorizer on training data
vec = CountVectorizer()
X_train_vec = vec.fit_transform(X_train)

# Get feature names (terms)
features = np.array(vec.get_feature_names_out())

# Sum the occurrences of each feature (term) across all documents
term_freq = np.asarray(X_train_vec.sum(axis=0)).flatten()

# Sort the features by frequency
sorted_idx = np.argsort(term_freq)[::-1]
top_n = 10  # Number of top terms to visualize
top_features = features[sorted_idx][:top_n]
top_freqs = term_freq[sorted_idx][:top_n]

# Plot the top features
plt.figure(figsize=(10, 6))
plt.barh(top_features, top_freqs, color='skyblue')
plt.xlabel('Frequency')
plt.title(f'Top {top_n} Most Frequent Features in SociaMedia Text')
plt.gca().invert_yaxis()  # To have the most frequent on top
plt.show()

"""Identify Target and Features"""

from textblob import TextBlob

# Sample social media posts
posts = [
    "I love this new phone! It's amazing ðŸ˜",
    "I'm so tired of this, everything is going wrong ðŸ˜”",
    "What a beautiful day, the sun is shining ðŸŒž",
    "This is terrible, I can't believe it! ðŸ˜¡"
]

# Function to decode emotions
def decode_emotions(posts):
    for post in posts:
        # Create a TextBlob object
        blob = TextBlob(post)

        # Get sentiment polarity (-1 to 1)
        sentiment = blob.sentiment.polarity

        # Classify sentiment into categories
        if sentiment > 0:
            emotion = 'Positive'
        elif sentiment < 0:
            emotion = 'Negative'
        else:
            emotion = 'Neutral'

        print(f"Post: {post}\nEmotion: {emotion}\nPolarity: {sentiment}\n")

# Run the sentiment analysis
decode_emotions(posts)

"""Convert Categorical Columns to Numerical"""

import pandas as pd
from sklearn.preprocessing import LabelEncoder

# Sample dataset (social media posts and their sentiments)
data = {
    'Post': [
        "I love this phone! It's amazing ðŸ˜",
        "I'm so tired of this, everything is bad ðŸ˜ž",
        "What a beautiful day ðŸŒž",
        "This is horrible! ðŸ˜¡"
    ],
    'Sentiment': ['Positive', 'Negative', 'Neutral', 'Negative']
}

# Convert to DataFrame
df = pd.DataFrame(data)

# Initialize LabelEncoder
label_encoder = LabelEncoder()

# Convert categorical 'Sentiment' column to numerical values
df['Sentiment_Numerical'] = label_encoder.fit_transform(df['Sentiment'])

# Show the transformed DataFrame
print(df)

"""One-Hot Encoding"""

import pandas as pd

# Sample data: social media posts and their emotion labels
data = {
    'Post': [
        "This party is awesome! ðŸŽ‰",
        "I can't take this anymore... ðŸ˜¡",
        "Feeling down today. Nothing's going right ðŸ˜¢",
        "Such a peaceful evening ðŸ˜Š"
    ],
    'Emotion': ['Happy', 'Angry', 'Sad', 'Happy']
}

# Convert to DataFrame
df = pd.DataFrame(data)

# One-Hot Encode the 'Emotion' column
df_encoded = pd.get_dummies(df, columns=['Emotion'], prefix='Emotion')

# Print the result
print(df_encoded)

"""Feature Scaling"""

!pip install scikit-learn pandas

scaler = StandardScaler()
scaled_features = scaler.fit_transform(tfidf_array)

"""Train-Test Split"""

import pandas as pd
from sklearn.model_selection import train_test_split

# Assuming 'socialmedia_data.csv' contains your data with 'text' and 'emotion' columns
# If the file has a different name, change it here
try:
    data = pd.read_csv('socialmedia_data.csv')
except FileNotFoundError:
    print("Error: 'socialmedia_data.csv' not found. Please make sure the file is in the correct directory or upload it.")
    # If the file needs to be uploaded, you can use:
    # from google.colab import files
    # uploaded = files.upload()
    # Then adjust the filename in pd.read_csv accordingly
else:
    X_train, X_test, y_train, y_test = train_test_split(data['text'], data['emotion'], test_size=0.2, random_state=42)

"""Model Building"""

from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import MultinomialNB

texts = ["I am happy", "I feel sad", "I'm so excited", "This is frustrating"]
labels = ["happy", "sad", "happy", "angry"]

X_train, X_test, y_train, y_test = train_test_split(texts, labels)
vec = CountVectorizer()
X_train_vec = vec.fit_transform(X_train)
model = MultinomialNB()
model.fit(X_train_vec, y_train)

"""Evaluation"""

from textblob import TextBlob

# Example social media posts
tweets = [
    "I love the new phone update! So smooth and fast. ðŸ˜",
    "Why does this app crash all the time? So annoying! ðŸ˜¡",
    "Just another day, nothing special.",
    "Feeling grateful for all the good things today. ðŸ˜Š",
    "I'm tired of all the negativity in the news."
]

def analyze_sentiment(text):
    blob = TextBlob(text)
    polarity = blob.sentiment.polarity

    if polarity > 0:
        return "Positive"
    elif polarity < 0:
        return "Negative"
    else:
        return "Neutral"

print("Tweet Sentiment Analysis:\n")
for tweet in tweets:
    sentiment = analyze_sentiment(tweet)
    print(f"Tweet: {tweet}\nSentiment: {sentiment}\n")

"""Make Predictions from New Input"""

new_text = ["I can't stop smiling today!", "I'm really upset with everything"]
new_vec = vec.transform(new_text)
predictions = model.predict(new_vec)
print(predictions)

"""Convert to DataFrame and Encode"""

import pandas as pd
from sklearn.preprocessing import LabelEncoder

# Sample data
texts = ["I am happy", "I feel sad", "I'm so excited", "This is frustrating"]
emotions = ["happy", "sad", "happy", "angry"]

# Convert to DataFrame
df = pd.DataFrame({'text': texts, 'emotion': emotions})

# Encode emotions
encoder = LabelEncoder()
df['emotion_encoded'] = encoder.fit_transform(df['emotion'])

print(df)

"""Predict the Final Grade"""

from sklearn.preprocessing import LabelEncoder

# Encode labels (if not already done)
encoder = LabelEncoder()
y_train_enc = encoder.fit_transform(y_train)
model.fit(X_train_vec, y_train_enc)

# Predict on new input
new_text = ["I don't know what to feel, it's overwhelming"]
new_vec = vec.transform(new_text)
pred_encoded = model.predict(new_vec)
pred_label = encoder.inverse_transform(pred_encoded)

print("Predicted Emotion:", pred_label[0])

"""Deployment-Building an Interactive App"""

!pip install gradio

"""Create a Prediction Function"""

def predict_emotion(text):
    vec_input = vec.transform([text])
    pred_encoded = model.predict(vec_input)
    return encoder.inverse_transform(pred_encoded)[0]

# Example use
print(predict_emotion("I am feeling wonderful today!"))

"""Create the Gradio Interface"""

import gradio as gr

# Define the function to predict emotion
def predict_emotion(text):
    vec_input = vec.transform([text])
    pred_encoded = model.predict(vec_input)
    return encoder.inverse_transform(pred_encoded)[0]

# Create Gradio Interface
iface = gr.Interface(fn=predict_emotion,
                     inputs="text",
                     outputs="text",
                     live=True,
                     title="Emotion Decoding from Social Media Text",
                     description="Enter a social media text to predict its emotion.")

# Launch the interface
iface.launch()